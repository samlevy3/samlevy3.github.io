<div class="entropy-garden-container">
  <style>
    .entropy-garden-container * {
      box-sizing: border-box;
    }

    .entropy-garden-container {
      background: transparent;
      min-height: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Georgia, serif;
    }

    .entropy-garden-container .subtitle {
      color: #5a7a3a;
      margin-bottom: 15px;
      font-size: 14px;
    }

    .entropy-garden-container #canvas-container {
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    .entropy-garden-container .controls {
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 20px;
      border-radius: 8px;
      margin-top: 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      max-width: 900px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .entropy-garden-container .controls label {
      font-size: 13px;
      color: #333;
    }

    .entropy-garden-container .controls input[type="text"],
    .entropy-garden-container .controls input[type="number"],
    .entropy-garden-container .controls select,
    .entropy-garden-container .controls textarea {
      padding: 5px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 13px;
    }

    .entropy-garden-container .controls textarea {
      font-family: 'Courier New', monospace;
      line-height: 1.4;
    }

    .entropy-garden-container .controls input[type="number"] {
      width: 55px;
    }

    .entropy-garden-container .controls input[type="text"] {
      width: 200px;
    }

    .entropy-garden-container .controls input[type="color"] {
      width: 35px;
      height: 25px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }

    .entropy-garden-container .controls select {
      min-width: 140px;
    }

    .entropy-garden-container button {
      padding: 8px 14px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }

    .entropy-garden-container .plant-btn {
      background: #4a7c23;
      color: white;
    }

    .entropy-garden-container .plant-btn:hover {
      background: #5a9428;
    }

    .entropy-garden-container .sky-btn {
      background: #5ba4d4;
      color: white;
    }

    .entropy-garden-container .sky-btn:hover {
      background: #6bb4e4;
    }

    .entropy-garden-container .reset-btn {
      background: #c0392b;
      color: white;
    }

    .entropy-garden-container .reset-btn:hover {
      background: #e74c3c;
    }

    .entropy-garden-container .theme-btn {
      background: #455a64;
      color: white;
    }

    .entropy-garden-container .theme-btn:hover {
      background: #546e7a;
    }

    .entropy-garden-container .section-label {
      font-size: 13px;
      color: #555;
      margin-right: 5px;
      font-weight: bold;
    }

    .entropy-garden-container .color-group {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .entropy-garden-container .color-group span {
      font-size: 11px;
      color: #666;
    }

    .entropy-garden-container .instructions {
      font-size: 12px;
      color: #666;
      margin-top: 10px;
      text-align: center;
    }

    .entropy-garden-container .divider {
      width: 1px;
      height: 25px;
      background: #ddd;
      margin: 0 5px;
    }

    .entropy-garden-container .type-indicator {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 10px;
      background: #f0f0f0;
      color: #666;
      white-space: nowrap;
    }

    .entropy-garden-container .type-indicator.lsystem {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .entropy-garden-container .type-indicator.stochastic {
      background: #fce4ec;
      color: #c2185b;
    }

    .entropy-garden-container .type-indicator.ifs {
      background: #fff3e0;
      color: #e65100;
    }

    .entropy-garden-container .algo-description {
      font-size: 11px;
      color: #666;
      font-style: italic;
      width: 100%;
      margin-top: -5px;
      padding: 8px 12px;
      background: #f9f9f9;
      border-radius: 4px;
    }

    .entropy-garden-container .param-group {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .entropy-garden-container .full-width {
      width: 100%;
    }

    .entropy-garden-container optgroup {
      font-weight: bold;
      color: #333;
    }

    .entropy-garden-container option {
      font-weight: normal;
      padding: 4px;
    }

    /* Dark mode styles */
    .entropy-garden-container.dark-mode {
      background: linear-gradient(to bottom, #1a1a2e, #16213e);
    }

    .entropy-garden-container.dark-mode .controls {
      background: rgba(30, 30, 30, 0.9);
    }

    .entropy-garden-container.dark-mode .controls label,
    .entropy-garden-container.dark-mode .section-label,
    .entropy-garden-container.dark-mode .instructions {
      color: #e0e0e0;
    }

    .entropy-garden-container.dark-mode .type-indicator {
      background: #2a2a2a;
      color: #bbb;
    }

    .entropy-garden-container.dark-mode .algo-description {
      background: #252525;
      color: #ccc;
    }
  </style>

  <p class="subtitle"></p>
  <div id="canvas-container"></div>

  <div class="controls">
    <span class="section-label">Algorithm:</span>
    <select id="algorithmSelect" onchange="setPreset(this.value)">
      <optgroup label="Deterministic Plants">
        <option value="bush">Bush</option>
        <option value="tree">Tree</option>
        <option value="fern">Fern</option>
        <option value="fractal">Fractal</option>
        <option value="flower">Flower</option>
      </optgroup>
      <optgroup label="Stochastic Plants">
        <option value="wildBush">Wild Bush</option>
        <option value="wildTree">Wild Tree</option>
        <option value="vine">Vine</option>
        <option value="windswept">Windswept</option>
      </optgroup>
      <optgroup label="Sky Objects">
        <option value="sun">Sun</option>
        <option value="cloud">Cloud</option>
        <option value="star">Star</option>
      </optgroup>
    </select>
    <span class="type-indicator lsystem" id="typeIndicator">Deterministic L-System</span>
  </div>

  <div class="controls">
    <p class="algo-description" id="algoDescription">Classic branching pattern with symmetric growth.</p>
  </div>

  <div class="controls full-width">
    <div style="width: 100%;">
      <label style="display: block; margin-bottom: 8px; font-weight: bold;">Axiom:</label>
      <input type="text" id="axiom" value="F" style="width: 100%; font-family: 'Courier New', monospace;">
    </div>
  </div>

  <div class="controls full-width">
    <div style="width: 100%;">
      <label style="display: block; margin-bottom: 8px; font-weight: bold;">Rules: <span style="font-weight: normal; font-size: 11px; color: #666;">(one per line or comma-separated)</span></label>
      <textarea id="rule" style="width: 100%; min-height: 90px; font-family: 'Courier New', monospace; resize: vertical;">F=FF+[+F-F-F]-[-F+F+F]</textarea>
    </div>
  </div>

  <div class="controls">
    <span class="section-label">Generation:</span>
    <label>Iterations: <input type="number" id="gens" value="4" min="1" max="8"></label>
    <label>Growth Speed: <input type="number" id="growthSpeed" value="0.15" min="0.01" max="1" step="0.05" style="width: 70px;"></label>
  </div>

  <div class="controls">
    <span class="section-label">Geometry:</span>
    <label>Angle: <input type="number" id="angle" value="25" min="1" max="180"></label>
    <label>Length: <input type="number" id="length" value="8" min="1" max="50" step="1"></label>
    <label>Line Width: <input type="number" id="lineWidth" value="4" min="1" max="20" step="0.5" style="width: 60px;"></label>
    <label>Randomness: <input type="number" id="randomness" value="0" min="0" max="50" step="5" style="width: 50px;">%</label>
  </div>

  <div class="controls">
    <span class="section-label">Colors:</span>
    <div class="color-group">
      <span>Base</span>
      <input type="color" id="color0" value="#228B22">
    </div>
    <div class="color-group">
      <span>Mid</span>
      <input type="color" id="color1" value="#32CD32">
    </div>
    <div class="color-group">
      <span>Tips</span>
      <input type="color" id="color2" value="#90EE90">
    </div>
    <div class="divider"></div>
    <button class="reset-btn" onclick="resetGarden()">Clear All</button>
    <button class="theme-btn" onclick="toggleTheme()">ðŸŒ™ Night</button>
  </div>

  <p class="instructions">Select an algorithm, adjust parameters, then click the canvas to place</p>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script>
    (function() {
      let plants = [];
      let skyObjects = [];
      let plantMode = 'ground';
      let currentType = 'lsystem';

      const presets = {
        bush: {
          type: 'lsystem',
          axiom: 'F',
          rule: 'F=FF+[+F-F-F]-[-F+F+F]',
          angle: 25,
          length: 8,
          colors: ['#228B22', '#32CD32', '#90EE90'],
          isSky: false,
          gens: 4,
          lineWidth: 4,
          randomness: 0,
          description: 'Classic branching pattern with symmetric growth.'
        },
        tree: {
          type: 'lsystem',
          axiom: 'X',
          rule: 'X=F[+X][-X]FX\nF=FF',
          angle: 30,
          length: 8,
          colors: ['#4a3728', '#5d4a3a', '#6b8e23'],
          isSky: false,
          gens: 5,
          lineWidth: 5,
          randomness: 0,
          description: 'Recursive tree with alternating branches.'
        },
        fern: {
          type: 'lsystem',
          axiom: 'X',
          rule: 'X=F+[[X]-X]-F[-FX]+X\nF=FF',
          angle: 25,
          length: 8,
          colors: ['#2e7d32', '#43a047', '#a5d6a7'],
          isSky: false,
          gens: 5,
          lineWidth: 3,
          randomness: 0,
          description: 'Curved fronds inspired by natural ferns.'
        },
        fractal: {
          type: 'lsystem',
          axiom: 'F',
          rule: 'F=F[+F]F[-F]F',
          angle: 26,
          length: 8,
          colors: ['#4a148c', '#7b1fa2', '#ce93d8'],
          isSky: false,
          gens: 4,
          lineWidth: 3,
          randomness: 0,
          description: 'Pure self-similar fractal branching.'
        },
        flower: {
          type: 'lsystem',
          axiom: 'X',
          rule: 'X=F[+X][-X]FX\nF=FF',
          angle: 42,
          length: 8,
          colors: ['#558b2f', '#7cb342', '#f06292'],
          isSky: false,
          gens: 5,
          lineWidth: 3,
          randomness: 0,
          description: 'Wide branching angles create flower-like spread.'
        },
        wildBush: {
          type: 'stochastic',
          axiom: 'F',
          rule: 'F=FF+[+F-F-F]-[-F+F+F]\nF=F[+F]F[-F]F\nF=FF-[-F+F]+[+F-F]',
          angle: 25,
          length: 8,
          colors: ['#2e7d32', '#66bb6a', '#a5d6a7'],
          isSky: false,
          gens: 4,
          lineWidth: 4,
          randomness: 15,
          description: 'Each F randomly picks one of three growth patterns. Every plant is unique.'
        },
        wildTree: {
          type: 'stochastic',
          axiom: 'X',
          rule: 'X=F[+X][-X]FX\nX=F[-X]FX\nX=F[+X]FX\nF=FF',
          angle: 28,
          length: 8,
          colors: ['#5d4037', '#795548', '#81c784'],
          isSky: false,
          gens: 5,
          lineWidth: 5,
          randomness: 20,
          description: 'Natural tree variation â€” branches may grow or skip randomly.'
        },
        vine: {
          type: 'stochastic',
          axiom: 'F',
          rule: 'F=F[+F]F\nF=F[-F]F\nF=FF\nF=F[+F][-F]F',
          angle: 30,
          length: 8,
          colors: ['#1b5e20', '#4caf50', '#c5e1a5'],
          isSky: false,
          gens: 5,
          lineWidth: 2,
          randomness: 25,
          description: 'Highly unpredictable vine growth with four possible paths.'
        },
        windswept: {
          type: 'stochastic',
          axiom: 'F',
          rule: 'F=FF+[+F-F]-[-F+F]\nF=FF+[+F]-[F]\nF=F+F-F',
          angle: 22,
          length: 8,
          colors: ['#37474f', '#607d8b', '#90a4ae'],
          isSky: false,
          gens: 4,
          lineWidth: 3,
          randomness: 30,
          description: 'Biased toward one direction, like wind-shaped growth.'
        },
        sun: {
          type: 'lsystem',
          axiom: '[G]++[G]++[G]++[G]++[G]',
          rule: 'F=HJ++IJ----GJ[-HJ----FJ]++\nG=+HJ--IJ[---FJ--GJ]+\nH=-FJ++GJ[+++HJ++IJ]-\nI=--HJ++++FJ[+IJ++++GJ]--GJ\nJ=',
          angle: 36,
          length: 10,
          colors: ['#ffb300', '#ffd54f', '#fff9c4'],
          isSky: true,
          scale: 0.8,
          gens: 5,
          lineWidth: 1,
          randomness: 0,
          description: 'Pentagonal fractal sun with multi-letter rules.'
        },
        cloud: {
          type: 'ifs',
          ifsSets: [
            [0.0, 0.577, -0.577, 0.0, 0.0951, 0.5983, 1 / 3],
            [0.0, 0.577, -0.577, 0.0, 0.4413, 0.7893, 1 / 3],
            [0.0, 0.577, -0.577, 0.0, 0.0952, 0.9893, 1 / 3]
          ],
          colors: ['#90a4ae', '#b0bec5', '#eceff1'],
          isSky: true,
          pointCount: 8000,
          scale: 200,
          lineWidth: 2,
          randomness: 100,
          description: 'Iterated Function System â€” chaos game point cloud.'
        },
        star: {
          type: 'lsystem',
          axiom: 'F',
          rule: 'F=F[++F][--F][+F][-F]F',
          angle: 36,
          length: 6,
          colors: ['#ffd54f', '#ffeb3b', '#fffde7'],
          isSky: true,
          scale: 0.3,
          gens: 4,
          lineWidth: 2,
          randomness: 0,
          description: 'Radial star burst with pentagonal symmetry.'
        }
      };

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        ] : [0, 0, 0];
      }

      window.setPreset = function(name) {
        const p = presets[name];
        if (!p) return;

        currentType = p.type;

        const indicator = document.getElementById('typeIndicator');
        if (p.type === 'ifs') {
          indicator.textContent = 'IFS (Chaos Game)';
          indicator.className = 'type-indicator ifs';
        } else if (p.type === 'stochastic') {
          indicator.textContent = 'Stochastic L-System';
          indicator.className = 'type-indicator stochastic';
        } else {
          indicator.textContent = 'Deterministic L-System';
          indicator.className = 'type-indicator lsystem';
        }

        document.getElementById('algoDescription').textContent = p.description;

        if (p.type === 'lsystem' || p.type === 'stochastic') {
          document.getElementById('axiom').value = p.axiom;
          document.getElementById('rule').value = p.rule;
          document.getElementById('angle').value = p.angle;
          document.getElementById('gens').value = p.gens || 4;
          document.getElementById('lineWidth').value = p.lineWidth || 4;
          document.getElementById('randomness').value = p.randomness || 0;
          document.getElementById('length').value = p.length || 8;
        } else {
          document.getElementById('axiom').value = '(IFS mode)';
          document.getElementById('rule').value = '(probabilistic transforms)';
          document.getElementById('angle').value = '-';
          document.getElementById('gens').value = '-';
          document.getElementById('lineWidth').value = p.lineWidth || 2;
          document.getElementById('randomness').value = 100;
          document.getElementById('length').value = '-';
        }

        document.getElementById('color0').value = p.colors[0];
        document.getElementById('color1').value = p.colors[1];
        document.getElementById('color2').value = p.colors[2];

        setPlantMode(p.isSky ? 'sky' : 'ground');
      };

      window.setPlantMode = function(mode) {
        plantMode = mode;
      };

      window.resetGarden = function() {
        plants = [];
        skyObjects = [];
      };

      window.toggleTheme = function() {
        const container = document.querySelector('.entropy-garden-container');
        container.classList.toggle('dark-mode');
        const btn = event.target;
        if (container.classList.contains('dark-mode')) {
          btn.textContent = 'â˜€ï¸ Day';
        } else {
          btn.textContent = 'ðŸŒ™ Night';
        }
      };

      function getCurrentConfig() {
        if (currentType === 'ifs') {
          return {
            type: 'ifs',
            ifsSets: presets.cloud.ifsSets,
            colors: [
              document.getElementById('color0').value,
              document.getElementById('color1').value,
              document.getElementById('color2').value
            ],
            pointCount: presets.cloud.pointCount,
            scale: presets.cloud.scale,
            lineWidth: parseFloat(document.getElementById('lineWidth').value) || 2,
            growthSpeed: parseFloat(document.getElementById('growthSpeed').value) || 0.15
          };
        }

        const axiom = document.getElementById('axiom').value;
        const ruleStr = document.getElementById('rule').value;
        const angle = parseInt(document.getElementById('angle').value) || 25;
        const gens = parseInt(document.getElementById('gens').value) || 4;
        const length = parseInt(document.getElementById('length').value) || 8;
        const lineWidth = parseFloat(document.getElementById('lineWidth').value) || 4;
        const randomness = parseInt(document.getElementById('randomness').value) || 0;
        const growthSpeed = parseFloat(document.getElementById('growthSpeed').value) || 0.15;
        const colors = [
          document.getElementById('color0').value,
          document.getElementById('color1').value,
          document.getElementById('color2').value
        ];

        return {
          type: currentType,
          axiom,
          rule: ruleStr,
          angle,
          gens,
          length,
          colors,
          lineWidth,
          randomness,
          growthSpeed
        };
      }

      function parseRules(ruleStr) {
        const ruleMap = {};
        
        // Only use newlines to separate rules (ignore | character)
        const rules = ruleStr.split('\n').filter(r => r.trim());

        rules.forEach(r => {
          const parts = r.trim().split('=');
          if (parts.length === 2) {
            const symbol = parts[0].trim();
            const production = parts[1].trim();

            if (!ruleMap[symbol]) {
              ruleMap[symbol] = [];
            }
            // Each line with same symbol becomes an alternative
            ruleMap[symbol].push(production);
          }
        });

        return ruleMap;
      }

      function applyRules(sentence, ruleMap, isStochastic) {
        let next = '';
        for (let char of sentence) {
          if (ruleMap[char]) {
            const alternatives = ruleMap[char];
            // If multiple alternatives exist, pick randomly (auto-stochastic)
            // Otherwise use the first one (deterministic)
            if (alternatives.length > 1) {
              const pick = Math.floor(Math.random() * alternatives.length);
              next += alternatives[pick];
            } else {
              next += alternatives[0];
            }
          } else {
            next += char;
          }
        }
        return next;
      }

      function addObject(x, y, config, isSky) {
        if (config.type === 'ifs') {
          const obj = createIFSObject(x, y, config);
          if (isSky) skyObjects.push(obj);
          else plants.push(obj);
        } else {
          const obj = createLSystemObject(x, y, config, isSky);
          if (isSky) skyObjects.push(obj);
          else plants.push(obj);
        }
      }

      function createIFSObject(x, y, config) {
        const points = generateIFSPoints(config.ifsSets, config.pointCount, config.scale);

        return {
          type: 'ifs',
          x: x,
          y: y,
          points: points,
          currentPoint: 0,
          colors: config.colors.map(hexToRgb),
          complete: false,
          scale: config.scale,
          lineWidth: config.lineWidth || 2,
          growthSpeed: config.growthSpeed || 0.15
        };
      }

      function generateIFSPoints(ifsSets, count, scale) {
        const points = [];
        let px = 0, py = 0;

        for (let i = 0; i < 20; i++) {
          const r = Math.random();
          let cumProb = 0;
          for (const set of ifsSets) {
            cumProb += set[6];
            if (r <= cumProb) {
              const [a, b, c, d, e, f] = set;
              const newX = a * px + b * py + e;
              const newY = c * px + d * py + f;
              px = newX;
              py = newY;
              break;
            }
          }
        }

        for (let i = 0; i < count; i++) {
          const r = Math.random();
          let cumProb = 0;
          for (const set of ifsSets) {
            cumProb += set[6];
            if (r <= cumProb) {
              const [a, b, c, d, e, f] = set;
              const newX = a * px + b * py + e;
              const newY = c * px + d * py + f;
              px = newX;
              py = newY;

              points.push({
                x: (px - 0.3) * scale,
                y: (py - 0.8) * scale,
                depth: Math.random()
              });
              break;
            }
          }
        }

        return points;
      }

      function createLSystemObject(x, y, config, isSky) {
        let sentence = config.axiom;
        const ruleMap = parseRules(config.rule);
        const gens = config.gens || 4;
        const isStochastic = config.type === 'stochastic';

        for (let i = 0; i < gens; i++) {
          sentence = applyRules(sentence, ruleMap, isStochastic);
        }

        const scale = config.scale || 1;
        const randomness = config.randomness || 0;
        const baseLength = config.length || 8;
        const segments = parseLSystem(sentence, config.angle, gens, isSky, scale, randomness, baseLength);

        return {
          type: 'lsystem',
          x: x,
          y: y,
          segments: segments,
          currentSegment: 0,
          growthProgress: 0,
          colors: config.colors.map(hexToRgb),
          complete: false,
          isSky: isSky,
          lineWidth: config.lineWidth || 4,
          growthSpeed: config.growthSpeed || 0.15
        };
      }

      function parseLSystem(sentence, angle, gens, isSky, scale = 1, randomness = 0, baseLength = 8) {
        const segments = [];
        const stack = [];
        let x = 0, y = 0;
        let dir = isSky ? 0 : -90;
        const len = baseLength * scale * Math.pow(0.65, gens - 1);
        let depth = 0;

        const randFactor = randomness / 100;

        for (let char of sentence) {
          if (/[A-Z]/.test(char)) {
            const randLen = len * (1 + (Math.random() - 0.5) * randFactor);
            const randDir = dir + (Math.random() - 0.5) * angle * randFactor;

            const newX = x + randLen * cos(randDir);
            const newY = y + randLen * sin(randDir);
            segments.push({
              x1: x, y1: y,
              x2: newX, y2: newY,
              depth: depth
            });
            x = newX;
            y = newY;
          } else if (char === '+') {
            dir += angle * (1 + (Math.random() - 0.5) * randFactor);
          } else if (char === '-' || char === 'âˆ’') {
            dir -= angle * (1 + (Math.random() - 0.5) * randFactor);
          } else if (char === '[') {
            stack.push({ x, y, dir, depth });
            depth++;
          } else if (char === ']') {
            const state = stack.pop();
            if (state) {
              x = state.x;
              y = state.y;
              dir = state.dir;
              depth = state.depth;
            }
          }
        }

        return segments;
      }

      window.setup = function() {
        let canvas = createCanvas(800, 600);
        canvas.parent('canvas-container');
        angleMode(DEGREES);

        setPreset('bush');
      };

      window.mousePressed = function() {
        if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;

        const config = getCurrentConfig();
        const isSky = plantMode === 'sky';

        addObject(mouseX, mouseY, config, isSky);
      };

      window.draw = function() {
        const isDark = document.querySelector('.entropy-garden-container').classList.contains('dark-mode');

        for (let y = 0; y < height - 80; y++) {
          let inter = map(y, 0, height - 80, 0, 1);
          let c;
          if (isDark) {
            c = lerpColor(color(25, 25, 60), color(10, 10, 30), inter);
          } else {
            c = lerpColor(color(135, 206, 235), color(240, 248, 255), inter);
          }
          stroke(c);
          line(0, y, width, y);
        }

        for (let obj of skyObjects) {
          if (obj.type === 'ifs') {
            drawIFSObject(obj);
            growIFSObject(obj);
          } else {
            drawLSystemObject(obj);
            growLSystemObject(obj);
          }
        }

        noStroke();
        if (isDark) {
          fill(40, 35, 30);
        } else {
          fill(139, 119, 101);
        }
        rect(0, height - 80, width, 80);

        if (isDark) {
          fill(30, 45, 25);
        } else {
          fill(86, 125, 70);
        }
        rect(0, height - 80, width, 15);

        if (isDark) {
          stroke(25, 35, 20);
        } else {
          stroke(76, 115, 60);
        }
        strokeWeight(1);
        randomSeed(42);
        for (let i = 0; i < width; i += 6) {
          let h = random(5, 18);
          let sway = random(-3, 3);
          line(i, height - 80, i + sway, height - 80 - h);
        }

        for (let plant of plants) {
          if (plant.type === 'ifs') {
            drawIFSObject(plant);
            growIFSObject(plant);
          } else {
            drawLSystemObject(plant);
            growLSystemObject(plant);
          }
        }

        if (plantMode) {
          noFill();
          strokeWeight(2);
          if (plantMode === 'sky') {
            stroke(91, 164, 212, 150);
            ellipse(mouseX, mouseY, 35, 35);
          } else {
            stroke(76, 175, 80, 150);
            ellipse(mouseX, mouseY, 30, 30);
            line(mouseX, mouseY - 15, mouseX, mouseY - 28);
          }
          strokeWeight(1);
        }
      };

      function drawIFSObject(obj) {
        push();
        translate(obj.x, obj.y);

        const pointsToDraw = min(obj.currentPoint, obj.points.length);

        for (let i = 0; i < pointsToDraw; i++) {
          const p = obj.points[i];
          const col = getColorForDepth(p.depth, obj.colors);
          stroke(col[0], col[1], col[2], 180);
          strokeWeight(obj.lineWidth);
          point(p.x, p.y);
        }

        pop();
      }

      function growIFSObject(obj) {
        if (obj.complete) return;
        const speed = obj.growthSpeed || 0.15;
        obj.currentPoint += Math.floor(speed * 800);
        if (obj.currentPoint >= obj.points.length) {
          obj.complete = true;
        }
      }

      function drawLSystemObject(obj) {
        push();
        translate(obj.x, obj.y);

        let maxDepth = 1;
        for (let seg of obj.segments) {
          if (seg.depth > maxDepth) maxDepth = seg.depth;
        }

        for (let i = 0; i < obj.currentSegment && i < obj.segments.length; i++) {
          drawSegment(obj.segments[i], obj.colors, maxDepth, 1, obj.lineWidth, obj.isSky);
        }

        if (obj.currentSegment < obj.segments.length) {
          const seg = obj.segments[obj.currentSegment];
          drawSegment(seg, obj.colors, maxDepth, obj.growthProgress, obj.lineWidth, obj.isSky);
        }

        pop();
      }

      function getColorForDepth(t, colors) {
        let r, g, b;
        if (t < 0.5) {
          const t2 = t * 2;
          r = lerp(colors[0][0], colors[1][0], t2);
          g = lerp(colors[0][1], colors[1][1], t2);
          b = lerp(colors[0][2], colors[1][2], t2);
        } else {
          const t2 = (t - 0.5) * 2;
          r = lerp(colors[1][0], colors[2][0], t2);
          g = lerp(colors[1][1], colors[2][1], t2);
          b = lerp(colors[1][2], colors[2][2], t2);
        }
        return [r, g, b];
      }

      function drawSegment(seg, colors, maxDepth, progress, baseLineWidth, isSky) {
        const t = maxDepth > 0 ? seg.depth / maxDepth : 0;
        const col = getColorForDepth(t, colors);

        stroke(col[0], col[1], col[2]);

        const thickness = max(baseLineWidth - seg.depth * (baseLineWidth * 0.15), 1);
        strokeWeight(thickness);

        const x2 = lerp(seg.x1, seg.x2, progress);
        const y2 = lerp(seg.y1, seg.y2, progress);
        line(seg.x1, seg.y1, x2, y2);
      }

      function growLSystemObject(obj) {
        if (obj.complete) return;

        const speed = obj.growthSpeed || 0.15;
        obj.growthProgress += speed;

        if (obj.growthProgress >= 1) {
          obj.growthProgress = 0;
          obj.currentSegment++;

          if (obj.currentSegment >= obj.segments.length) {
            obj.complete = true;
          }
        }
      }
    })();
  </script>
</div>