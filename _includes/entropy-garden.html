<div class="entropy-garden-container">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L-System Garden</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
      .entropy-garden-container :is(h1, h2, p, ul, ol, blockquote, pre, code, figure, table) {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Georgia, serif;
        color: #333;
      }

      .entropy-garden-container {
        background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-bottom: 30px;
      }

      .subtitle {
        color: #5a7a3a;
        margin-bottom: 15px;
        font-size: 14px;
      }

      #canvas-container {
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      }

      .controls {
        background: rgba(255, 255, 255, 0.9);
        padding: 15px 20px;
        border-radius: 8px;
        margin-top: 15px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        max-width: 900px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .controls label {
        font-size: 13px;
        color: #333;
      }

      .controls input[type="text"],
      .controls input[type="number"],
      .controls select {
        padding: 5px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
      }

      .controls input[type="number"] {
        width: 55px;
      }

      .controls input[type="text"] {
        width: 200px;
      }

      .controls input[type="color"] {
        width: 35px;
        height: 25px;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
      }

      .controls select {
        min-width: 140px;
      }

      button {
        padding: 8px 14px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
      }

      .plant-btn {
        background: #4a7c23;
        color: white;
      }

      .plant-btn:hover {
        background: #5a9428;
      }

      .sky-btn {
        background: #5ba4d4;
        color: white;
      }

      .sky-btn:hover {
        background: #6bb4e4;
      }

      .reset-btn {
        background: #c0392b;
        color: white;
      }

      .reset-btn:hover {
        background: #e74c3c;
      }

      .section-label {
        font-size: 13px;
        color: #555;
        margin-right: 5px;
        font-weight: bold;
      }

      .color-group {
        display: flex;
        gap: 4px;
        align-items: center;
      }

      .color-group span {
        font-size: 11px;
        color: #666;
      }

      .instructions {
        font-size: 12px;
        color: #666;
        margin-top: 10px;
        text-align: center;
      }

      .divider {
        width: 1px;
        height: 25px;
        background: #ddd;
        margin: 0 5px;
      }

      .type-indicator {
        font-size: 11px;
        padding: 3px 8px;
        border-radius: 10px;
        background: #f0f0f0;
        color: #666;
        white-space: nowrap;
      }

      .type-indicator.lsystem {
        background: #e8f5e9;
        color: #2e7d32;
      }

      .type-indicator.stochastic {
        background: #fce4ec;
        color: #c2185b;
      }

      .type-indicator.ifs {
        background: #fff3e0;
        color: #e65100;
      }

      .algo-description {
        font-size: 11px;
        color: #666;
        font-style: italic;
        width: 100%;
        margin-top: -5px;
        padding: 8px 12px;
        background: #f9f9f9;
        border-radius: 4px;
      }

      .param-group {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      optgroup {
        font-weight: bold;
        color: #333;
      }

      option {
        font-weight: normal;
        padding: 4px;
      }
    </style>
    <p class="subtitle"></p>
    <div id="canvas-container"></div>

    <div class="controls">
      <span class="section-label">Algorithm:</span>
      <select id="algorithmSelect" onchange="setPreset(this.value)">
        <optgroup label="Deterministic Plants">
          <option value="bush">Bush</option>
          <option value="tree">Tree</option>
          <option value="fern">Fern</option>
          <option value="fractal">Fractal</option>
          <option value="flower">Flower</option>
        </optgroup>
        <optgroup label="Stochastic Plants">
          <option value="wildBush">Wild Bush</option>
          <option value="wildTree">Wild Tree</option>
          <option value="vine">Vine</option>
          <option value="windswept">Windswept</option>
        </optgroup>
        <optgroup label="Sky Objects">
          <option value="sun">Sun</option>
          <option value="cloud">Cloud</option>
          <option value="star">Star</option>
        </optgroup>
      </select>
      <span class="type-indicator lsystem" id="typeIndicator">Deterministic L-System</span>
    </div>

    <div class="controls">
      <p class="algo-description" id="algoDescription">Classic branching pattern with symmetric growth.</p>
    </div>

    <div class="controls">
      <div class="param-group">
        <label>Axiom: <input type="text" id="axiom" value="F"></label>
        <label>Rule(s): <input type="text" id="rule" value="F=FF+[+F-F-F]-[-F+F+F]" style="width: 280px;"></label>
      </div>
    </div>

    <div class="controls">
      <div class="param-group">
        <label>Generations: <input type="number" id="gens" value="4" min="1" max="8"></label>
        <label>Angle: <input type="number" id="angle" value="25" min="1" max="180"></label>
        <label>Line Width: <input type="number" id="lineWidth" value="4" min="1" max="20" step="0.5"></label>
        <label>Randomness: <input type="number" id="randomness" value="0" min="0" max="50" step="5">%</label>
        <label>Growth Speed: <input type="number" id="growthSpeed" value="0.15" min="0.01" max="1" step="0.05"></label>
      </div>
    </div>

    <div class="controls">
      <span class="section-label">Colors:</span>
      <div class="color-group">
        <span>Base</span>
        <input type="color" id="color0" value="#228B22">
      </div>
      <div class="color-group">
        <span>Mid</span>
        <input type="color" id="color1" value="#32CD32">
      </div>
      <div class="color-group">
        <span>Tips</span>
        <input type="color" id="color2" value="#90EE90">
      </div>
      <div class="divider"></div>
      <button class="reset-btn" onclick="resetGarden()">Clear All</button>
      <button class="theme-btn" onclick="toggleTheme()">üåô Night</button>
    </div>

    <p class="instructions">Select an algorithm, adjust parameters, then click the canvas to place</p>

    <script>
      let plants = [];
      let skyObjects = [];
      let plantMode = 'ground';
      let currentType = 'lsystem';

      const presets = {
        // === DETERMINISTIC PLANTS ===
        bush: {
          type: 'lsystem',
          axiom: 'F',
          rule: 'F=FF+[+F-F-F]-[-F+F+F]',
          angle: 25,
          colors: ['#228B22', '#32CD32', '#90EE90'],
          isSky: false,
          gens: 4,
          lineWidth: 4,
          randomness: 0,
          description: 'Classic branching pattern with symmetric growth.'
        },
        tree: {
          type: 'lsystem',
          axiom: 'X',
          rule: 'X=F[+X][-X]FX,F=FF',
          angle: 30,
          colors: ['#4a3728', '#5d4a3a', '#6b8e23'],
          isSky: false,
          gens: 5,
          lineWidth: 5,
          randomness: 0,
          description: 'Recursive tree with alternating branches.'
        },
        fern: {
          type: 'lsystem',
          axiom: 'X',
          rule: 'X=F+[[X]-X]-F[-FX]+X,F=FF',
          angle: 25,
          colors: ['#2e7d32', '#43a047', '#a5d6a7'],
          isSky: false,
          gens: 5,
          lineWidth: 3,
          randomness: 0,
          description: 'Curved fronds inspired by natural ferns.'
        },
        fractal: {
          type: 'lsystem',
          axiom: 'F',
          rule: 'F=F[+F]F[-F]F',
          angle: 26,
          colors: ['#4a148c', '#7b1fa2', '#ce93d8'],
          isSky: false,
          gens: 4,
          lineWidth: 3,
          randomness: 0,
          description: 'Pure self-similar fractal branching.'
        },
        flower: {
          type: 'lsystem',
          axiom: 'X',
          rule: 'X=F[+X][-X]FX,F=FF',
          angle: 42,
          colors: ['#558b2f', '#7cb342', '#f06292'],
          isSky: false,
          gens: 5,
          lineWidth: 3,
          randomness: 0,
          description: 'Wide branching angles create flower-like spread.'
        },

        // === STOCHASTIC PLANTS ===
        wildBush: {
          type: 'stochastic',
          axiom: 'F',
          rule: 'F=FF+[+F-F-F]-[-F+F+F]|F[+F]F[-F]F|FF-[-F+F]+[+F-F]',
          angle: 25,
          colors: ['#2e7d32', '#66bb6a', '#a5d6a7'],
          isSky: false,
          gens: 4,
          lineWidth: 4,
          randomness: 15,
          description: 'Each F randomly picks one of three growth patterns. Every plant is unique.'
        },
        wildTree: {
          type: 'stochastic',
          axiom: 'X',
          rule: 'X=F[+X][-X]FX|F[-X]FX|F[+X]FX,F=FF',
          angle: 28,
          colors: ['#5d4037', '#795548', '#81c784'],
          isSky: false,
          gens: 5,
          lineWidth: 5,
          randomness: 20,
          description: 'Natural tree variation ‚Äî branches may grow or skip randomly.'
        },
        vine: {
          type: 'stochastic',
          axiom: 'F',
          rule: 'F=F[+F]F|F[-F]F|FF|F[+F][-F]F',
          angle: 30,
          colors: ['#1b5e20', '#4caf50', '#c5e1a5'],
          isSky: false,
          gens: 5,
          lineWidth: 2,
          randomness: 25,
          description: 'Highly unpredictable vine growth with four possible paths.'
        },
        windswept: {
          type: 'stochastic',
          axiom: 'F',
          rule: 'F=FF+[+F-F]-[-F+F]|FF+[+F]-[F]|F+F-F',
          angle: 22,
          colors: ['#37474f', '#607d8b', '#90a4ae'],
          isSky: false,
          gens: 4,
          lineWidth: 3,
          randomness: 30,
          description: 'Biased toward one direction, like wind-shaped growth.'
        },

        // === SKY OBJECTS ===
        sun: {
          type: 'lsystem',
          axiom: 'F[+F][-F][++F][--F][+++F][---F][++++F][----F][+++++F][-----F][++++++F][------F]',
          rule: 'F=FF',
          angle: 36,
          colors: ['#ffb300', '#ffd54f', '#fff9c4'],
          isSky: true,
          scale: 0.6,
          gens: 5,
          lineWidth: 4,
          randomness: 5,
          description: 'Bright sun with multiple radiating rays.'
        },
        cloud: {
          type: 'ifs',
          ifsSets: [
            [0.0, 0.577, -0.577, 0.0, 0.0951, 0.5983, 1 / 3],
            [0.0, 0.577, -0.577, 0.0, 0.4413, 0.7893, 1 / 3],
            [0.0, 0.577, -0.577, 0.0, 0.0952, 0.9893, 1 / 3]
          ],
          colors: ['#90a4ae', '#b0bec5', '#eceff1'],
          isSky: true,
          pointCount: 8000,
          scale: 200,
          lineWidth: 2,
          randomness: 100,
          description: 'Iterated Function System ‚Äî chaos game point cloud.'
        },
        star: {
          type: 'lsystem',
          axiom: 'F',
          rule: 'F=F[++F][--F][+F][-F]F',
          angle: 36,
          colors: ['#ffd54f', '#ffeb3b', '#fffde7'],
          isSky: true,
          scale: 0.3,
          gens: 4,
          lineWidth: 2,
          randomness: 0,
          description: 'Radial star burst with pentagonal symmetry.'
        },
      };

      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        ] : [0, 0, 0];
      }

      function setPreset(name) {
        const p = presets[name];
        if (!p) return;

        currentType = p.type;

        // Update type indicator
        const indicator = document.getElementById('typeIndicator');
        if (p.type === 'ifs') {
          indicator.textContent = 'IFS (Chaos Game)';
          indicator.className = 'type-indicator ifs';
        } else if (p.type === 'stochastic') {
          indicator.textContent = 'Stochastic L-System';
          indicator.className = 'type-indicator stochastic';
        } else {
          indicator.textContent = 'Deterministic L-System';
          indicator.className = 'type-indicator lsystem';
        }

        // Update description
        document.getElementById('algoDescription').textContent = p.description;

        if (p.type === 'lsystem' || p.type === 'stochastic') {
          document.getElementById('axiom').value = p.axiom;
          document.getElementById('rule').value = p.rule;
          document.getElementById('angle').value = p.angle;
          document.getElementById('gens').value = p.gens || 4;
          document.getElementById('lineWidth').value = p.lineWidth || 4;
          document.getElementById('randomness').value = p.randomness || 0;
        } else {
          document.getElementById('axiom').value = '(IFS mode)';
          document.getElementById('rule').value = '(probabilistic transforms)';
          document.getElementById('angle').value = '-';
          document.getElementById('gens').value = '-';
          document.getElementById('lineWidth').value = p.lineWidth || 2;
          document.getElementById('randomness').value = 100;
        }

        document.getElementById('color0').value = p.colors[0];
        document.getElementById('color1').value = p.colors[1];
        document.getElementById('color2').value = p.colors[2];

        setPlantMode(p.isSky ? 'sky' : 'ground');
      }

      function setPlantMode(mode) {
        plantMode = mode;
      }

      function resetGarden() {
        plants = [];
        skyObjects = [];
      }

      function setup() {
        let canvas = createCanvas(800, 600);
        canvas.parent('canvas-container');
        angleMode(DEGREES);

        // Set initial preset
        setPreset('bush');
      }


      function mousePressed() {
        if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;

        const config = getCurrentConfig();
        const isSky = plantMode === 'sky';

        addObject(mouseX, mouseY, config, isSky);
      }

      function getCurrentConfig() {
        if (currentType === 'ifs') {
          return {
            type: 'ifs',
            ifsSets: presets.cloud.ifsSets,
            colors: [
              document.getElementById('color0').value,
              document.getElementById('color1').value,
              document.getElementById('color2').value
            ],
            pointCount: presets.cloud.pointCount,
            scale: presets.cloud.scale,
            lineWidth: parseFloat(document.getElementById('lineWidth').value) || 2,
            growthSpeed: parseFloat(document.getElementById('growthSpeed').value) || 0.15
          };
        }

        const axiom = document.getElementById('axiom').value;
        const ruleStr = document.getElementById('rule').value;
        const angle = parseInt(document.getElementById('angle').value) || 25;
        const gens = parseInt(document.getElementById('gens').value) || 4;
        const lineWidth = parseFloat(document.getElementById('lineWidth').value) || 4;
        const randomness = parseInt(document.getElementById('randomness').value) || 0;
        const growthSpeed = parseFloat(document.getElementById('growthSpeed').value) || 0.15;
        const colors = [
          document.getElementById('color0').value,
          document.getElementById('color1').value,
          document.getElementById('color2').value
        ];

        return {
          type: currentType,
          axiom,
          rule: ruleStr,
          angle,
          gens,
          colors,
          lineWidth,
          randomness,
          growthSpeed
        };
      }

      function parseRules(ruleStr) {
        // Parse rules, handling stochastic rules separated by |
        const ruleMap = {};

        ruleStr.split(',').forEach(r => {
          const parts = r.trim().split('=');
          if (parts.length === 2) {
            const symbol = parts[0].trim();
            const alternatives = parts[1].split('|').map(a => a.trim());

            if (!ruleMap[symbol]) {
              ruleMap[symbol] = [];
            }
            ruleMap[symbol] = ruleMap[symbol].concat(alternatives);
          }
        });

        return ruleMap;
      }

      function applyRules(sentence, ruleMap, isStochastic) {
        let next = '';
        for (let char of sentence) {
          if (ruleMap[char]) {
            const alternatives = ruleMap[char];
            if (isStochastic && alternatives.length > 1) {
              // Randomly pick one alternative
              const pick = Math.floor(Math.random() * alternatives.length);
              next += alternatives[pick];
            } else {
              next += alternatives[0];
            }
          } else {
            next += char;
          }
        }
        return next;
      }

      function addObject(x, y, config, isSky) {
        if (config.type === 'ifs') {
          const obj = createIFSObject(x, y, config);
          if (isSky) skyObjects.push(obj);
          else plants.push(obj);
        } else {
          const obj = createLSystemObject(x, y, config, isSky);
          if (isSky) skyObjects.push(obj);
          else plants.push(obj);
        }
      }

      function createIFSObject(x, y, config) {
        const points = generateIFSPoints(config.ifsSets, config.pointCount, config.scale);

        return {
          type: 'ifs',
          x: x,
          y: y,
          points: points,
          currentPoint: 0,
          colors: config.colors.map(hexToRgb),
          complete: false,
          scale: config.scale,
          lineWidth: config.lineWidth || 2,
          growthSpeed: config.growthSpeed || 0.15
        };
      }

      function generateIFSPoints(ifsSets, count, scale) {
        const points = [];
        let px = 0, py = 0;

        for (let i = 0; i < 20; i++) {
          const r = Math.random();
          let cumProb = 0;
          for (const set of ifsSets) {
            cumProb += set[6];
            if (r <= cumProb) {
              const [a, b, c, d, e, f] = set;
              const newX = a * px + b * py + e;
              const newY = c * px + d * py + f;
              px = newX;
              py = newY;
              break;
            }
          }
        }

        for (let i = 0; i < count; i++) {
          const r = Math.random();
          let cumProb = 0;
          for (const set of ifsSets) {
            cumProb += set[6];
            if (r <= cumProb) {
              const [a, b, c, d, e, f] = set;
              const newX = a * px + b * py + e;
              const newY = c * px + d * py + f;
              px = newX;
              py = newY;

              points.push({
                x: (px - 0.3) * scale,
                y: (py - 0.8) * scale,
                depth: Math.random()
              });
              break;
            }
          }
        }

        return points;
      }

      function createLSystemObject(x, y, config, isSky) {
        let sentence = config.axiom;
        const ruleMap = parseRules(config.rule);
        const gens = config.gens || 4;
        const isStochastic = config.type === 'stochastic';

        for (let i = 0; i < gens; i++) {
          sentence = applyRules(sentence, ruleMap, isStochastic);
        }

        const scale = config.scale || 1;
        const randomness = config.randomness || 0;
        const segments = parseLSystem(sentence, config.angle, gens, isSky, scale, randomness);

        return {
          type: 'lsystem',
          x: x,
          y: y,
          segments: segments,
          currentSegment: 0,
          growthProgress: 0,
          colors: config.colors.map(hexToRgb),
          complete: false,
          isSky: isSky,
          lineWidth: config.lineWidth || 4,
          growthSpeed: config.growthSpeed || 0.15
        };
      }

      function parseLSystem(sentence, angle, gens, isSky, scale = 1, randomness = 0) {
        const segments = [];
        const stack = [];
        let x = 0, y = 0;
        let dir = isSky ? 0 : -90;
        const baseLen = isSky ? 6 : 8;
        const len = baseLen * scale * Math.pow(0.65, gens - 1);
        let depth = 0;

        const randFactor = randomness / 100;

        for (let char of sentence) {
          if (char === 'F') {
            // Add randomness to length and direction
            const randLen = len * (1 + (Math.random() - 0.5) * randFactor);
            const randDir = dir + (Math.random() - 0.5) * angle * randFactor;

            const newX = x + randLen * cos(randDir);
            const newY = y + randLen * sin(randDir);
            segments.push({
              x1: x, y1: y,
              x2: newX, y2: newY,
              depth: depth
            });
            x = newX;
            y = newY;
          } else if (char === '+') {
            dir += angle * (1 + (Math.random() - 0.5) * randFactor);
          } else if (char === '-' || char === '‚àí') {
            dir -= angle * (1 + (Math.random() - 0.5) * randFactor);
          } else if (char === '[') {
            stack.push({ x, y, dir, depth });
            depth++;
          } else if (char === ']') {
            const state = stack.pop();
            if (state) {
              x = state.x;
              y = state.y;
              dir = state.dir;
              depth = state.depth;
            }
          }
        }

        return segments;
      }

      function draw() {
        const isDark = document.body.classList.contains('dark-mode');

        // Sky gradient - changes based on theme
        for (let y = 0; y < height - 80; y++) {
          let inter = map(y, 0, height - 80, 0, 1);
          let c;
          if (isDark) {
            // Night sky: dark blue to darker blue
            c = lerpColor(color(25, 25, 60), color(10, 10, 30), inter);
          } else {
            // Day sky: light blue
            c = lerpColor(color(135, 206, 235), color(240, 248, 255), inter);
          }
          stroke(c);
          line(0, y, width, y);
        }

        // Draw sky objects
        for (let obj of skyObjects) {
          if (obj.type === 'ifs') {
            drawIFSObject(obj);
            growIFSObject(obj);
          } else {
            drawLSystemObject(obj);
            growLSystemObject(obj);
          }
        }

        // Ground - darker at night
        noStroke();
        if (isDark) {
          fill(40, 35, 30); // Dark brown for night
        } else {
          fill(139, 119, 101); // Regular brown
        }
        rect(0, height - 80, width, 80);

        // Grass layer - darker at night
        if (isDark) {
          fill(30, 45, 25); // Dark green
        } else {
          fill(86, 125, 70); // Regular green
        }
        rect(0, height - 80, width, 15);

        // Grass blades - darker at night
        if (isDark) {
          stroke(25, 35, 20);
        } else {
          stroke(76, 115, 60);
        }
        strokeWeight(1);
        randomSeed(42);
        for (let i = 0; i < width; i += 6) {
          let h = random(5, 18);
          let sway = random(-3, 3);
          line(i, height - 80, i + sway, height - 80 - h);
        }

        // Draw plants
        for (let plant of plants) {
          if (plant.type === 'ifs') {
            drawIFSObject(plant);
            growIFSObject(plant);
          } else {
            drawLSystemObject(plant);
            growLSystemObject(plant);
          }
        }

        // Cursor hint
        if (plantMode) {
          noFill();
          strokeWeight(2);
          if (plantMode === 'sky') {
            stroke(91, 164, 212, 150);
            ellipse(mouseX, mouseY, 35, 35);
          } else {
            stroke(76, 175, 80, 150);
            ellipse(mouseX, mouseY, 30, 30);
            line(mouseX, mouseY - 15, mouseX, mouseY - 28);
          }
          strokeWeight(1);
        }
      }

      function drawIFSObject(obj) {
        push();
        translate(obj.x, obj.y);

        const pointsToDraw = min(obj.currentPoint, obj.points.length);

        for (let i = 0; i < pointsToDraw; i++) {
          const p = obj.points[i];
          const col = getColorForDepth(p.depth, obj.colors);
          stroke(col[0], col[1], col[2], 180);
          strokeWeight(obj.lineWidth);
          point(p.x, p.y);
        }

        pop();
      }

      function growIFSObject(obj) {
        if (obj.complete) return;
        const speed = obj.growthSpeed || 0.15;  // Use stored speed
        obj.currentPoint += Math.floor(speed * 800);  // Scale for IFS points
        if (obj.currentPoint >= obj.points.length) {
          obj.complete = true;
        }
      }

      function drawLSystemObject(obj) {
        push();
        translate(obj.x, obj.y);

        let maxDepth = 1;
        for (let seg of obj.segments) {
          if (seg.depth > maxDepth) maxDepth = seg.depth;
        }

        for (let i = 0; i < obj.currentSegment && i < obj.segments.length; i++) {
          drawSegment(obj.segments[i], obj.colors, maxDepth, 1, obj.lineWidth, obj.isSky);
        }

        if (obj.currentSegment < obj.segments.length) {
          const seg = obj.segments[obj.currentSegment];
          drawSegment(seg, obj.colors, maxDepth, obj.growthProgress, obj.lineWidth, obj.isSky);
        }

        pop();
      }

      function getColorForDepth(t, colors) {
        let r, g, b;
        if (t < 0.5) {
          const t2 = t * 2;
          r = lerp(colors[0][0], colors[1][0], t2);
          g = lerp(colors[0][1], colors[1][1], t2);
          b = lerp(colors[0][2], colors[1][2], t2);
        } else {
          const t2 = (t - 0.5) * 2;
          r = lerp(colors[1][0], colors[2][0], t2);
          g = lerp(colors[1][1], colors[2][1], t2);
          b = lerp(colors[1][2], colors[2][2], t2);
        }
        return [r, g, b];
      }

      function drawSegment(seg, colors, maxDepth, progress, baseLineWidth, isSky) {
        const t = maxDepth > 0 ? seg.depth / maxDepth : 0;
        const col = getColorForDepth(t, colors);

        stroke(col[0], col[1], col[2]);

        // Line width tapers with depth
        const thickness = max(baseLineWidth - seg.depth * (baseLineWidth * 0.15), 1);
        strokeWeight(thickness);

        const x2 = lerp(seg.x1, seg.x2, progress);
        const y2 = lerp(seg.y1, seg.y2, progress);
        line(seg.x1, seg.y1, x2, y2);
      }

      function growLSystemObject(obj) {
        if (obj.complete) return;

        const speed = obj.growthSpeed || 0.15;  // Use stored speed
        obj.growthProgress += speed;

        if (obj.growthProgress >= 1) {
          obj.growthProgress = 0;
          obj.currentSegment++;

          if (obj.currentSegment >= obj.segments.length) {
            obj.complete = true;
          }
        }
      }

      function toggleTheme() {
        document.body.classList.toggle('dark-mode');
        const btn = event.target;
        if (document.body.classList.contains('dark-mode')) {
          btn.textContent = '‚òÄÔ∏è Day';
        } else {
          btn.textContent = 'üåô Night';
        }
      }
    </script>

</div>